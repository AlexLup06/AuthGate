===== FILE: ./cmd/authgate/main.go =====
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/alexlup06/authgate/internal/auth"
	"github.com/alexlup06/authgate/internal/config"
	httpserver "github.com/alexlup06/authgate/internal/http"
	"github.com/alexlup06/authgate/internal/logging"
	"github.com/alexlup06/authgate/internal/session"
	"github.com/alexlup06/authgate/internal/store"
	"github.com/alexlup06/authgate/internal/store/schema"
	"github.com/alexlup06/authgate/internal/store/tx"
)

func main() {
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("failed to load config: %v", err)
	}

	logger, err := logging.New(cfg.Logging.Level)
	logger.Info("starting authgate")

	store, err := store.New(store.Config{
		Host:     cfg.DB.Host,
		Port:     cfg.DB.Port,
		Username: cfg.DB.Username,
		Password: cfg.DB.Password,
		Database: cfg.DB.Database,
		Schema:   cfg.DB.Schema,
		Timezone: cfg.DB.Timezone,
		LogSql:   cfg.DB.LogSQL,
	})
	if err != nil {
		logger.Error("failed to connect to database", "err", err)
		os.Exit(1)
	}

	startupCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	schemaVersion, err := store.CurrentSchemaVersion(startupCtx)
	if err != nil {
		logger.Error("failed to read schema version", "err", err)
		os.Exit(1)
	}

	if schemaVersion != schema.RequiredSchemaVersion {
		logger.Error(
			"database schema version mismatch",
			"current", schemaVersion,
			"required", schema.RequiredSchemaVersion,
		)
		os.Exit(1)
	}

	txManager := tx.New(store)

	authService := auth.New(auth.Config{
		Store: store,
		Tx:    txManager,
	})

	sessionService := session.New(session.Config{
		Store: store,
	})

	server := httpserver.NewServer(httpserver.Config{
		Addr:    cfg.HTTP.Addr,
		Auth:    authService,
		Session: sessionService,
		Logger:  logger,
	})

	ctx, stop := signal.NotifyContext(
		context.Background(),
		os.Interrupt,
		syscall.SIGTERM,
	)
	defer stop()

	go func() {
		logger.Info("http server listening", "addr", cfg.HTTP.Addr)
		if err := server.Start(); err != nil {
			logger.Error("http server stopped unexpectedly", "err", err)
			stop()
		}
	}()

	<-ctx.Done()

	logger.Info("shutting down authgate")

	shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := server.Shutdown(shutdownCtx); err != nil {
		logger.Error("graceful shutdown failed", "err", err)
	}

	logger.Info("authgate stopped")
}

===== FILE: ./migrations/Dockerfile =====
ARG ALPINE_VERSION=3.19
ARG GO_VERSION=1.25

FROM golang:${GO_VERSION}-alpine${ALPINE_VERSION} as base

RUN apk add --no-cache postgresql-client ca-certificates
RUN go install github.com/rubenv/sql-migrate/...@latest

WORKDIR /migrations

COPY . .

ENTRYPOINT ["sql-migrate"]

===== FILE: ./migrations/README.md =====
# AuthGate Database Migrations

This directory contains the **database schema migrations required by AuthGate**.

AuthGate **does not manage database schema automatically**.  
Migrations must be applied **explicitly** before running the AuthGate server.

---

## Overview

- AuthGate requires a PostgreSQL database
- The database schema is versioned using SQL migrations
- Migrations are applied using `sql-migrate`
- AuthGate **will refuse to start** if the database schema version is incompatible

This design is intentional and ensures:
- explicit infrastructure changes
- safe upgrades and rollbacks
- no hidden side effects at runtime

---

## Migration Tooling

AuthGate provides a **dedicated migration runner Docker image** built from this directory.

The migration image:
- contains all SQL migrations
- contains the `sql-migrate` CLI
- does **not** start AuthGate
- exits after applying migrations

---

## Running Migrations (Docker – Recommended)

### Prerequisites

You must provide database connection details via environment variables, for example:

POSTGRESQL_HOST=localhost  
POSTGRESQL_PORT=5432  
POSTGRESQL_DATABASE=authgate  
POSTGRESQL_USERNAME=authgate  
POSTGRESQL_PASSWORD=secret  

### Apply migrations

docker run --rm \
  --env-file .env \
  ghcr.io/<your-org>/authgate-migrate:<version> up

This command:
- connects to the database
- applies all pending migrations
- exits immediately

---

## Checking Migration Status

docker run --rm \
  --env-file .env \
  ghcr.io/<your-org>/authgate-migrate:<version> status

---

## Rolling Back (Advanced)

docker run --rm \
  --env-file .env \
  ghcr.io/<your-org>/authgate-migrate:<version> down

⚠️ **Warning:** Rolling back migrations may result in data loss.  
Only perform rollbacks if you fully understand the impact.

---

## Schema Compatibility Enforcement

AuthGate **validates schema compatibility on startup**.

If the database schema version does not match the version required by the AuthGate server, startup will fail with an error similar to:

database schema version mismatch  
current: 002_users  
required: 003_sessions  

In this case, apply the correct migrations before starting AuthGate.

---

## Design Principles

- AuthGate **does not own your database**
- Schema changes are **explicit**
- Migrations are **operator-controlled**
- Runtime behavior is **deterministic and safe**

This is infrastructure software — not an application that mutates shared state automatically.

---

## Summary

- Migrations are required to run AuthGate
- Migrations must be applied explicitly
- AuthGate will not auto-migrate
- Schema compatibility is enforced at startup

If AuthGate starts successfully, the database schema is guaranteed to be correct.

===== FILE: ./migrations/dbconfig.yaml =====
development:
  dialect: postgres
  datasource: host=${POSTGRESQL_HOST} port=${POSTGRESQL_PORT} dbname=${POSTGRESQL_DATABASE} user=${POSTGRESQL_USERNAME} password=${POSTGRESQL_PASSWORD} sslmode=disable
  schema: public
  dir: .
  table: backend_migrations

===== FILE: ./migrations/01-init.sql =====
-- +migrate Up
CREATE SCHEMA IF NOT EXISTS app;

CREATE TABLE IF NOT EXISTS app.user (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,

	username varchar(255) NOT NULL,
	email varchar(255) NOT NULL,

	CONSTRAINT unique_user_email UNIQUE (email)
	CONSTRAINT user_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS app.auth_provider (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,

	user_id UUID NOT NULL REFERENCES app.user(id) ON DELETE CASCADE,
	method VARCHAR(50) NOT NULL,
	provider_user_id VARCHAR(255),
	password_hash VARCHAR(255),
	two_factor_authentication BOOLEAN DEFAULT FALSE,

	CONSTRAINT unique_provider_user UNIQUE (method, provider_user_id),
	CONSTRAINT auth_provider_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS app.session (
	id uuid NOT NULL,
	created_at timestamptz NOT NULL,
	updated_at timestamptz NOT NULL,

	user_id UUID NOT NULL REFERENCES app.user(id) ON DELETE CASCADE,  

	refresh_token VARCHAR(512) NOT NULL UNIQUE,           
	issued_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),         
	expires_at TIMESTAMPTZ NOT NULL,                      
	revoked BOOLEAN NOT NULL DEFAULT FALSE,               

	user_agent VARCHAR(255),                              

	CONSTRAINT unique_token UNIQUE (refresh_token),                
	CONSTRAINT refresh_token_pkey PRIMARY KEY (id)
);

-- +migrate Down
DROP SCHEMA app cascade;

===== FILE: ./go.mod =====
module github.com/alexlup06/authgate

go 1.25.1

require (
	github.com/go-chi/chi/v5 v5.2.3
	github.com/sethvargo/go-envconfig v1.3.0
	gorm.io/driver/postgres v1.6.0
	gorm.io/gorm v1.31.1
)

require (
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.6.0 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/sync v0.10.0 // indirect
	golang.org/x/text v0.21.0 // indirect
)

===== FILE: ./docker/Dockerfile.prod =====
# ---------- Frontend Builder ----------
FROM node:20-alpine AS frontend-builder

WORKDIR /app

COPY frontend/package.json frontend/package-lock.json ./frontend/
RUN cd frontend && npm ci

COPY frontend ./frontend
COPY internal/http/templates ./internal/http/templates

RUN cd frontend && npm run build

# ---------- Backend Builder ----------
FROM golang:1.25-alpine AS backend-builder

WORKDIR /app

RUN apk add --no-cache git

# Install templ
RUN go install github.com/a-h/templ/cmd/templ@v0.3.819

COPY go.mod go.sum ./
RUN go mod download

COPY . .

# Generate templ files
RUN templ generate

# Copy frontend assets into server static dir
COPY --from=frontend-builder /frontend/dist ./internal/http/static

# Build binary
RUN go build -o /bin/authgate ./cmd/authgate

# ---------- Runtime ----------
FROM alpine:3.19

RUN apk add --no-cache ca-certificates
RUN adduser -D -g '' authgate

USER authgate
WORKDIR /home/authgate

COPY --from=backend-builder /bin/authgate ./authgate

EXPOSE 8080

ENTRYPOINT ["./authgate"]

===== FILE: ./docker/Dockerfile.dev =====
FROM golang:1.25-alpine3.19

RUN go install github.com/a-h/templ/cmd/templ@v0.3.819
RUN go install github.com/bokwoon95/wgo@latest

WORKDIR /app

COPY . .

RUN go mod download

CMD ["wgo", "-file=.go", "-file=.templ", "-xfile=_templ.go", "templ" ,"generate" ,"::", "go" ,"run" ,"main.go"]

===== FILE: ./frontend/tailwind.config.js =====
module.exports = {
	content: [
		"../internal/http/**/*.templ",
		"./src/**/*.ts",
	],
	mode: "jit",
	theme: {
		extend: {
			spacing: {
				"nav-height-lg": "96px",
				"nav-height-sm": "80px"
			},
			screens: {
				'xs': '480px',
			},
		},
		colors: {
			transparent: 'transparent',
			current: 'currentColor',
			'white': '#ffffff',
			'black': '#000000',
			"background": "#ECF7FB",
			"main": {
				50: "#ecfbf7",
				100: "#c5f2e6",
				200: "#9ee9d6",
				300: "#77e0c6",
				400: "#50d7b5",
				500: "#3CD3AD",
				600: "#30a98a",
				700: "#247f68",
				800: "#185445",
				900: "#061511",
			},
			"second": {
				25: "#eee8e9",
				50: "#ddd1d4",
				100: "#ccbabe",
				200: "#aa8c93",
				300: "#875d68",
				400: "#652f3d",
				500: "#541827",
				600: "#43131f",
				700: "#320e17",
				800: "#220a10",
				900: "#110508",
			},
			"third": {
				25: "#e8e9ee",
				50: "#babecc",
				100: "#8c93aa",
				200: "#5d6887",
				300: "#465276",
				400: "#2f3d65",
				500: "#182754",
				600: "#16234c",
				700: "#131f43",
				800: "#0e1732",
				900: "#0a1022",
			},
			"grey": {
				50: "#f9fafb",
				100: "#f3f4f6",
				200: "#e5e7eb",
				300: "#d1d5db",
				400: "#9ca3af",
				500: "#6b7280",
				600: "#4b5563",
				700: "#374151",
				800: "#1f2937",
				900: "#111827",
				950: "#030712"
			}
		},
	},
	corePlugins: {
		preflight: true,
	},
};

===== FILE: ./frontend/dist/app.css =====

===== FILE: ./frontend/dist/app.js =====
(()=>{"use strict";window.htmx.config.allowNestedOobSwaps=!1,window.htmx.config.defaultSwapStyle="outerHTML",document.body.addEventListener("htmx:beforeSwap",function(t){422!==t.detail.xhr.status&&400!==t.detail.xhr.status||(t.detail.shouldSwap=!0,t.detail.isError=!1)})})();
===== FILE: ./frontend/webpack.config.js =====
const path = require('path');

module.exports = (env, argv) => ({
  mode: argv.mode || 'development',

  entry: './src/main.ts',

  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'app.js',
  },

  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },

  resolve: {
    extensions: ['.ts', '.js'],
  },

  devtool: argv.mode === 'production' ? false : 'source-map',
});

===== FILE: ./frontend/package.json =====
{
  "name": "authgate",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev:webpack": "webpack --mode development --watch",
    "dev:tailwind": "tailwindcss -i ./src/styles/style.css -o ./dist/app.css --watch",
    "build": "npm run build:webpack && npm run build:tailwind",
    "build:webpack": "rm -rf dist && webpack --mode production",
    "build:tailwind": "tailwindcss -i ./src/styles/style.css -o ./dist/app.css --minify"
  },
  "devDependencies": {
    "@tailwindcss/cli": "^4.1.18",
    "@tailwindcss/container-queries": "^0.1.1",
    "autoprefixer": "^10.4.20",
    "tailwindcss": "^4.1.18",
    "ts-loader": "^9.5.1",
    "typescript": "^5.7.2",
    "webpack": "^5.97.1",
    "webpack-cli": "^6.0.1"
  }
}

===== FILE: ./frontend/tsconfig.json =====
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
    /* Language and Environment */
    "target": "ES2020", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
    /* Modules */
    "module": "ESNext", /* Specify what module code is generated. */
    "rootDir": "./src", /* Specify the root folder within your source files. */
    "moduleResolution": "node", /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./src/dist", /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true, /* Ensure that casing is correct in imports. */
    /* Type Checking */
    "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
  "include": [
    "src/**/*.ts"
  ]
}

===== FILE: ./frontend/src/main.ts =====
export { }

declare global {
	interface Window {
		htmx: any;
	}
}

window.htmx.config.allowNestedOobSwaps = false; // Disable nested OOB swaps
window.htmx.config.defaultSwapStyle = "outerHTML" // Disable nested OOB swaps

document.body.addEventListener('htmx:beforeSwap', function(evt: any) {
	// Allow 422 and 400 responses to swap
	// We treat these as form validation errors
	if (evt.detail.xhr.status === 422 || evt.detail.xhr.status === 400) {
		evt.detail.shouldSwap = true;
		evt.detail.isError = false;
	}
});

===== FILE: ./frontend/src/styles/style.css =====

===== FILE: ./LICENSE =====
MIT License

Copyright (c) 2026 Alexander Lupatsiy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===== FILE: ./compose/docker-compose.dev.yml =====
services:

  frontend:
    image: node:20-alpine
    working_dir: /frontend
    volumes:
      - ./frontend:/frontend
    command: npm run dev:webpack


  postgres:
    image: postgres:16.2
    restart: always
    environment:
      POSTGRES_DB: ${POSTGRESQL_DATABASE}
      POSTGRES_USER: ${POSTGRESQL_USERNAME}
      POSTGRES_PASSWORD: ${POSTGRESQL_PASSWORD}
    healthcheck:
      test: "/usr/bin/pg_isready --dbname=${POSTGRESQL_DATABASE} --username=${POSTGRESQL_USERNAME} || exit 1"
      interval: 10s
      timeout: 5s
      retries: 5
    volumes:
      - postgres-data:/var/lib/postgresql/data

  backend-migrations:
    build:
      context: ./migrations
    env_file:
        - .env
    depends_on:
      postgres:
        condition: service_healthy
    command: "up"
    restart: "no"

  server:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - ./internal/http/static:/static
      - ./frontend/dist/app.js:/static/app.js

    env_file:
        - .env
    depends_on:
      backend-migrations:
        condition: service_completed_successfully

volumes:
  postgres-data:


===== FILE: ./internal/config/config.go =====
package config

import (
	"context"

	"github.com/sethvargo/go-envconfig"
)

type Config struct {
	Env string `env:"ENV,default=dev"`
	Dev bool   `env:"DEV_MODE,default=true"`

	DB      DB
	HTTP    HTTP
	Auth    Auth
	Logging Logging
}

func Load() (*Config, error) {
	var cfg Config
	if err := envconfig.Process(context.Background(), &cfg); err != nil {
		return nil, err
	}
	return &cfg, nil
}

===== FILE: ./internal/config/db.go =====
package config

type DB struct {
	Host     string `env:"POSTGRESQL_HOST,required"`
	Port     int    `env:"POSTGRESQL_PORT,required"`
	Username string `env:"POSTGRESQL_USERNAME,required"`
	Password string `env:"POSTGRESQL_PASSWORD,required"`
	Database string `env:"POSTGRESQL_DATABASE,required"`
	Schema   string `env:"POSTGRESQL_SCHEMA,default=public"`
	Timezone string `env:"POSTGRESQL_TIMEZONE,default=UTC"`
	LogSQL   bool   `env:"POSTGRESQL_LOG_SQL,default=false"`
}

===== FILE: ./internal/config/auth.go =====
package config

type Auth struct {
	JWTKey         string `env:"JWT_KEY,required"`
	GoogleClientID string `env:"GOOGLE_CLIENT_ID"`
}

===== FILE: ./internal/config/logging.go =====
package config

type Logging struct {
	Level string `env:"LOG_LEVEL,default=info"`
}

===== FILE: ./internal/config/http.go =====
package config

type HTTP struct {
	Addr string `env:"HTTP_ADDR,default=:8080"`
}

===== FILE: ./internal/auth/provider.go =====
package auth

===== FILE: ./internal/auth/service.go =====
package auth

import (
	"errors"

	"github.com/alexlup06/authgate/internal/store"
	"github.com/alexlup06/authgate/internal/store/tx"
)

var (
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrUserAlreadyExists  = errors.New("user already exists")
)

type Config struct {
	Store *store.Store
	Tx    *tx.Manager
}

type Service struct {
	store *store.Store
	tx    *tx.Manager
}

func New(cfg Config) *Service {
	return &Service{
		store: cfg.Store,
		tx:    cfg.Tx,
	}
}

// // Signup creates a user and password auth provider atomically.
// func (s *Service) Signup(
// 	ctx context.Context,
// 	email string,
// 	password string,
// ) (*domain.User, error) {
// 	var user domain.User
//
// 	err := s.tx.WithTransaction(ctx, func(txCtx context.Context) error {
// 		exists, err := s.store.UserExistsByEmail(txCtx, email)
// 		if err != nil {
// 			return err
// 		}
// 		if exists {
// 			return ErrUserAlreadyExists
// 		}
//
// 		hash, err := hashPassword(password)
// 		if err != nil {
// 			return err
// 		}
//
// 		user = domain.User{
// 			ID:    generateUserID(),
// 			Email: email,
// 		}
//
// 		if err := s.store.CreateUser(txCtx, user); err != nil {
// 			return err
// 		}
//
// 		provider := domain.AuthProvider{
// 			ID:           generateProviderID(),
// 			UserID:       user.ID,
// 			Type:         domain.ProviderPassword,
// 			PasswordHash: hash,
// 		}
//
// 		if err := s.store.CreateAuthProvider(txCtx, provider); err != nil {
// 			return err
// 		}
//
// 		return nil
// 	})
//
// 	if err != nil {
// 		return nil, err
// 	}
//
// 	return &user, nil
// }
//
// // Login validates credentials and returns the user.
// func (s *Service) Login(
// 	ctx context.Context,
// 	email string,
// 	password string,
// ) (*domain.User, error) {
// 	var (
// 		user     domain.User
// 		provider domain.AuthProvider
// 	)
//
// 	err := s.tx.WithTransaction(ctx, func(txCtx context.Context) error {
// 		var err error
//
// 		user, err = s.store.GetUserByEmail(txCtx, email)
// 		if err != nil {
// 			return ErrInvalidCredentials
// 		}
//
// 		provider, err = s.store.GetPasswordProviderByUserID(txCtx, user.ID)
// 		if err != nil {
// 			return ErrInvalidCredentials
// 		}
//
// 		if !verifyPassword(provider.PasswordHash, password) {
// 			return ErrInvalidCredentials
// 		}
//
// 		return nil
// 	})
//
// 	if err != nil {
// 		return nil, err
// 	}
//
// 	return &user, nil
// }

===== FILE: ./internal/auth/context.go =====
package auth

===== FILE: ./internal/auth/password.go =====
package auth

===== FILE: ./internal/auth/errors.go =====
package auth

===== FILE: ./internal/http/middleware/logging.go =====
package middleware

import (
	"net/http"
	"time"

	"log/slog"
)

func RequestLogger(logger *slog.Logger) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()

			// Wrap ResponseWriter to capture status code
			ww := &responseWriter{ResponseWriter: w, status: http.StatusOK}

			next.ServeHTTP(ww, r)

			logger.Info(
				"http request",
				"method", r.Method,
				"path", r.URL.Path,
				"status", ww.status,
				"duration_ms", time.Since(start).Milliseconds(),
				"remote_addr", r.RemoteAddr,
			)
		})
	}
}

type responseWriter struct {
	http.ResponseWriter
	status int
}

func (w *responseWriter) WriteHeader(status int) {
	w.status = status
	w.ResponseWriter.WriteHeader(status)
}

===== FILE: ./internal/http/server.go =====
package http

import (
	"context"
	"log/slog"
	"net/http"
	"time"

	"github.com/alexlup06/authgate/internal/auth"
	httpmiddleware "github.com/alexlup06/authgate/internal/http/middleware"
	"github.com/alexlup06/authgate/internal/session"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
)

type Server struct {
	httpServer *http.Server
}

type Config struct {
	Addr    string
	Auth    *auth.Service
	Session *session.Service
	Logger  *slog.Logger
}

func NewServer(cfg Config) *Server {
	r := chi.NewRouter()

	// ------------------------------------------------------------------
	// Global middleware (order matters)
	// ------------------------------------------------------------------
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Timeout(30 * time.Second))

	// Logging middleware (yours)
	r.Use(httpmiddleware.RequestLogger(cfg.Logger))

	// ------------------------------------------------------------------
	// Routes
	// ------------------------------------------------------------------
	registerRoutes(r, cfg)

	srv := &http.Server{
		Addr:         cfg.Addr,
		Handler:      r,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	return &Server{httpServer: srv}
}

func (s *Server) Start() error {
	return s.httpServer.ListenAndServe()
}

func (s *Server) Shutdown(ctx context.Context) error {
	return s.httpServer.Shutdown(ctx)
}

===== FILE: ./internal/http/context/user.go =====
package context

===== FILE: ./internal/http/context/request.go =====
package context

===== FILE: ./internal/http/routes.go =====
package http

import (
	"net/http"

	"github.com/alexlup06/authgate/internal/http/handlers"
	"github.com/go-chi/chi/v5"
)

func registerRoutes(r chi.Router, cfg Config) {
	// Health
	r.Get("/health", func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// Auth UI + API
	r.Route("/auth", func(r chi.Router) {
		h := handlers.NewAuthHandler(cfg.Auth, cfg.Session)

		r.Get("/login", h.LoginPage)
		r.Post("/login", h.Login)
		r.Post("/logout", h.Logout)

		r.Get("/signup", h.SignupPage)
		r.Post("/signup", h.Signup)
	})

	// // Session validation (for SDK / backends)
	// r.Get("/sessions/validate", func(w http.ResponseWriter, r *http.Request) {
	// 	user, err := cfg.Session.ValidateRequest(r)
	// 	if err != nil {
	// 		w.WriteHeader(http.StatusUnauthorized)
	// 		return
	// 	}
	// 	writeJSON(w, user)
	// })
}

===== FILE: ./internal/http/handlers/auth.go =====
package handlers

import (
	"net/http"

	"github.com/alexlup06/authgate/internal/auth"
	"github.com/alexlup06/authgate/internal/session"
)

type AuthHandler struct {
	auth    *auth.Service
	session *session.Service
}

func NewAuthHandler(
	authService *auth.Service,
	sessionService *session.Service,
) *AuthHandler {
	return &AuthHandler{
		auth:    authService,
		session: sessionService,
	}
}

func (h *AuthHandler) LoginPage(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("login page (placeholder)"))
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("login action (placeholder)"))
}

func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("logout action (placeholder)"))
}

func (h *AuthHandler) SignupPage(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("signup page (placeholder)"))
}

func (h *AuthHandler) Signup(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("signup action (placeholder)"))
}

===== FILE: ./internal/http/errors.go =====
package http

===== FILE: ./internal/domain/auth_provider.go =====

===== FILE: ./internal/domain/user.go =====

===== FILE: ./internal/domain/session.go =====

===== FILE: ./internal/logging/logging.go =====
package logging

import (
	"fmt"
	"os"
	"strings"

	"log/slog"
)

func New(level string) (*slog.Logger, error) {
	lvl, err := parseLevel(level)
	if err != nil {
		return nil, err
	}

	handler := slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: lvl,
	})

	return slog.New(handler), nil
}

func parseLevel(level string) (slog.Level, error) {
	switch strings.ToLower(level) {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error":
		return slog.LevelError, nil
	default:
		return slog.LevelInfo, fmt.Errorf("invalid log level: %s", level)
	}
}

===== FILE: ./internal/logging/context.go =====
package logging

===== FILE: ./internal/store/users.go =====
package store

===== FILE: ./internal/store/sessions.go =====
package store

===== FILE: ./internal/store/store.go =====
package store

import (
	"fmt"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
)

// Config is the configuration for the database.
type Config struct {
	Host     string `env:"POSTGRESQL_HOST, required"`
	Port     int    `env:"POSTGRESQL_PORT, required"`
	Username string `env:"POSTGRESQL_USERNAME, required"`
	Password string `env:"POSTGRESQL_PASSWORD, required"`
	Database string `env:"POSTGRESQL_DATABASE, required"`
	Timezone string `env:"POSTGRESQL_TIMEZONE, required"`
	Schema   string `env:"POSTGRESQL_SCHEMA, required"`
	LogSql   bool   `env:"POSTGRESQL_LOG_SQL, required"`
}

type Store struct {
	db *gorm.DB
}

func (s *Store) DB() *gorm.DB {
	return s.db
}

func New(cfg Config) (*Store, error) {
	dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s TimeZone=%s search_path=%s",
		cfg.Host, cfg.Port, cfg.Username, cfg.Password, cfg.Database, cfg.Timezone, cfg.Schema)

	var lg gormlogger.Interface
	if cfg.LogSql {
		lg = gormlogger.Default.LogMode(gormlogger.Info)
	}

	location, err := time.LoadLocation(cfg.Timezone)
	if err != nil {
		return nil, fmt.Errorf("can't load location %s: %w", cfg.Timezone, err)
	}

	gormConfig := gorm.Config{
		NowFunc: func() time.Time {
			return time.Now().In(location)
		},
		Logger:                 lg,
		SkipDefaultTransaction: true,
		PrepareStmt:            true,
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   cfg.Schema + ".",
			SingularTable: false,
		},
	}

	gormDB, err := gorm.Open(postgres.Open(dsn), &gormConfig)
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %w", err)
	}

	c := Store{db: gormDB}

	return &c, nil
}

===== FILE: ./internal/store/auth_providers.go =====
package store

===== FILE: ./internal/store/tx/manager.go =====
package tx

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/alexlup06/authgate/internal/store"
	"gorm.io/gorm"
)

type Manager struct {
	store *store.Store
}

func New(store *store.Store) *Manager {
	return &Manager{store: store}
}

type contextKey string

const (
	dbKey contextKey = "store.tx.db"
	txKey contextKey = "store.tx.state"
)

type transactionState struct {
	committed  bool
	rolledBack bool
}

// ---------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------

func (m *Manager) WithTransaction(
	ctx context.Context,
	fn func(context.Context) error,
) error {
	txCtx, cancel, err := m.withCancel(ctx)
	if err != nil {
		return err
	}
	defer cancel()

	if err := fn(txCtx); err != nil {
		if !isFinished(txCtx) {
			_ = m.Rollback(txCtx)
		}
		return err
	}

	if !isFinished(txCtx) {
		return m.Commit(txCtx)
	}

	return nil
}

func (m *Manager) Commit(ctx context.Context) error {
	db, err := getDB(ctx)
	if err != nil {
		return err
	}

	if err := db.Commit().Error; err != nil {
		return err
	}

	setCommitted(ctx)
	return nil
}

func (m *Manager) Rollback(ctx context.Context) error {
	if isCommitted(ctx) {
		return errors.New("transaction already committed")
	}

	db, err := getDB(ctx)
	if err != nil {
		return err
	}

	if err := db.Rollback().Error; err != nil {
		return err
	}

	setRolledBack(ctx)
	return nil
}

// ---------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------

func (m *Manager) withCancel(
	parent context.Context,
) (context.Context, context.CancelFunc, error) {
	ctx, cancel := context.WithCancel(parent)
	txCtx, err := m.withContext(ctx)
	return txCtx, cancel, err
}

func (m *Manager) withContext(
	parent context.Context,
) (context.Context, error) {
	session := m.store.DB().
		WithContext(parent).
		Begin(&sql.TxOptions{
			Isolation: sql.LevelReadCommitted,
		})

	if session.Error != nil {
		return nil, session.Error
	}

	ctx := context.WithValue(parent, dbKey, session)
	ctx = context.WithValue(ctx, txKey, &transactionState{})

	go m.cleanup(ctx)

	return ctx, nil
}

func (m *Manager) cleanup(ctx context.Context) {
	<-ctx.Done()
	if !isFinished(ctx) {
		_ = m.Rollback(ctx)
	}
}

// ---------------------------------------------------------------------
// Context utilities (store-internal only)
// ---------------------------------------------------------------------

func getDB(ctx context.Context) (*gorm.DB, error) {
	db, ok := ctx.Value(dbKey).(*gorm.DB)
	if !ok {
		return nil, fmt.Errorf("no transaction in context")
	}
	return db, nil
}

func isCommitted(ctx context.Context) bool {
	state, ok := ctx.Value(txKey).(*transactionState)
	return ok && state.committed
}

func isFinished(ctx context.Context) bool {
	state, ok := ctx.Value(txKey).(*transactionState)
	return ok && (state.committed || state.rolledBack)
}

func setCommitted(ctx context.Context) {
	if state, ok := ctx.Value(txKey).(*transactionState); ok {
		state.committed = true
	}
}

func setRolledBack(ctx context.Context) {
	if state, ok := ctx.Value(txKey).(*transactionState); ok {
		state.rolledBack = true
	}
}

===== FILE: ./internal/store/schema/version.go =====
package schema

const RequiredSchemaVersion = "002_users"

===== FILE: ./internal/store/context.go =====
package store

import (
	"context"

	"gorm.io/gorm"
)

type contextKey string

const dbKey contextKey = "store.tx.db"

// dbFromContext returns a transactional DB if present, otherwise base DB.
func (s *Store) dbFromContext(ctx context.Context) *gorm.DB {
	if txDB, ok := ctx.Value(dbKey).(*gorm.DB); ok {
		return txDB
	}
	return s.db
}

===== FILE: ./internal/store/model/auth_provider.go =====
package model

===== FILE: ./internal/store/model/user.go =====
package model

===== FILE: ./internal/store/model/session.go =====
package model

===== FILE: ./internal/store/schema.go =====
package store

import (
	"context"
	"database/sql"
)

func (s *Store) CurrentSchemaVersion(ctx context.Context) (string, error) {
	var version sql.NullString

	err := s.db.WithContext(ctx).
		Raw(`
			SELECT id
			FROM backend_migrations
			ORDER BY applied_at DESC
			LIMIT 1
		`).
		Scan(&version).Error

	if err != nil {
		return "", err
	}

	if !version.Valid {
		return "", nil // no migrations applied
	}

	return version.String, nil
}

===== FILE: ./internal/store/errors.go =====
package store

===== FILE: ./internal/session/service.go =====
package session

import (
	"errors"
	"time"

	"github.com/alexlup06/authgate/internal/store"
)

var (
	ErrNoSession      = errors.New("no session")
	ErrSessionExpired = errors.New("session expired")
	ErrInvalidSession = errors.New("invalid session")
)

type Config struct {
	Store *store.Store

	// cookie / session settings (can be extended later)
	CookieName string
	TTL        time.Duration
	Secure     bool
}

type Service struct {
	store      *store.Store
	cookieName string
	ttl        time.Duration
	secure     bool
}

func New(cfg Config) *Service {
	cookieName := cfg.CookieName
	if cookieName == "" {
		cookieName = "authgate_session"
	}

	ttl := cfg.TTL
	if ttl == 0 {
		ttl = 24 * time.Hour
	}

	return &Service{
		store:      cfg.Store,
		cookieName: cookieName,
		ttl:        ttl,
		secure:     cfg.Secure,
	}
}

// // Create creates a new session for a user and sets the session cookie.
// func (s *Service) Create(
// 	ctx context.Context,
// 	w http.ResponseWriter,
// 	user domain.User,
// ) (*domain.Session, error) {
// 	session := domain.Session{
// 		ID:        generateSessionID(),
// 		UserID:    user.ID,
// 		ExpiresAt: time.Now().Add(s.ttl),
// 	}
//
// 	if err := s.store.CreateSession(ctx, session); err != nil {
// 		return nil, err
// 	}
//
// 	s.setCookie(w, session.ID, session.ExpiresAt)
//
// 	return &session, nil
// }
//
// // ValidateRequest validates the session from the incoming request
// // and returns the associated user.
// func (s *Service) ValidateRequest(
// 	r *http.Request,
// ) (*domain.User, error) {
// 	sessionID, err := s.readCookie(r)
// 	if err != nil {
// 		return nil, ErrNoSession
// 	}
//
// 	session, err := s.store.GetSession(r.Context(), sessionID)
// 	if err != nil {
// 		return nil, ErrInvalidSession
// 	}
//
// 	if session.ExpiresAt.Before(time.Now()) {
// 		_ = s.store.DeleteSession(r.Context(), sessionID)
// 		return nil, ErrSessionExpired
// 	}
//
// 	user, err := s.store.GetUserByID(r.Context(), session.UserID)
// 	if err != nil {
// 		return nil, err
// 	}
//
// 	return &user, nil
// }
//
// // Destroy deletes the current session and clears the cookie.
// // It is intentionally idempotent.
// func (s *Service) Destroy(
// 	w http.ResponseWriter,
// 	r *http.Request,
// ) error {
// 	sessionID, err := s.readCookie(r)
// 	if err != nil {
// 		s.clearCookie(w)
// 		return nil
// 	}
//
// 	_ = s.store.DeleteSession(r.Context(), sessionID)
// 	s.clearCookie(w)
//
// 	return nil
// }

===== FILE: ./internal/session/context.go =====
package session

===== FILE: ./internal/session/cookie.go =====
package session

===== FILE: ./internal/session/manager.go =====
package session

===== FILE: ./internal/session/errors.go =====
package session

===== FILE: ./go.sum =====
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-chi/chi/v5 v5.2.3 h1:WQIt9uxdsAbgIYgid+BpYc+liqQZGMHRaUwp0JUcvdE=
github.com/go-chi/chi/v5 v5.2.3/go.mod h1:L2yAIGWB3H+phAw1NxKwWM+7eUH/lU8pOMm5hHcoops=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.6.0 h1:SWJzexBzPL5jb0GEsrPMLIsi/3jOo7RHlzTjcAeDrPY=
github.com/jackc/pgx/v5 v5.6.0/go.mod h1:DNZ/vlrUnhWCoFGxHAG8U2ljioxukquj7utPDgtQdTw=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sethvargo/go-envconfig v1.3.0 h1:gJs+Fuv8+f05omTpwWIu6KmuseFAXKrIaOZSh8RMt0U=
github.com/sethvargo/go-envconfig v1.3.0/go.mod h1:JLd0KFWQYzyENqnEPWWZ49i4vzZo/6nRidxI8YvGiHw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=
golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/postgres v1.6.0 h1:2dxzU8xJ+ivvqTRph34QX+WrRaJlmfyPqXmoGVjMBa4=
gorm.io/driver/postgres v1.6.0/go.mod h1:vUw0mrGgrTK+uPHEhAdV4sfFELrByKVGnaVRkXDhtWo=
gorm.io/gorm v1.31.1 h1:7CA8FTFz/gRfgqgpeKIBcervUn3xSyPUmr6B2WXJ7kg=
gorm.io/gorm v1.31.1/go.mod h1:XyQVbO2k6YkOis7C2437jSit3SsDK72s7n7rsSHd+Gs=

===== FILE: ./README.md =====
# AuthGate

