===== FILE: ./config/config.go =====
package config

import (
	"context"

	"github.com/sethvargo/go-envconfig"
)

type Config struct {
	Env string `env:"ENV,default=dev"`
	Dev bool   `env:"DEV_MODE,default=true"`

	DB      DB
	HTTP    HTTP
	Auth    Auth
	Logging Logging
}

func Load() (*Config, error) {
	var cfg Config
	if err := envconfig.Process(context.Background(), &cfg); err != nil {
		return nil, err
	}
	return &cfg, nil
}

===== FILE: ./config/db.go =====
package config

type DB struct {
	Host     string `env:"POSTGRESQL_HOST,required"`
	Port     int    `env:"POSTGRESQL_PORT,required"`
	Username string `env:"POSTGRESQL_USERNAME,required"`
	Password string `env:"POSTGRESQL_PASSWORD,required"`
	Database string `env:"POSTGRESQL_DATABASE,required"`
	Schema   string `env:"POSTGRESQL_SCHEMA,default=public"`
	Timezone string `env:"POSTGRESQL_TIMEZONE,default=UTC"`
	LogSQL   bool   `env:"POSTGRESQL_LOG_SQL,default=false"`
}

===== FILE: ./config/auth.go =====
package config

type Auth struct {
	JWTKey         string `env:"JWT_KEY,required"`
	GoogleClientID string `env:"GOOGLE_CLIENT_ID"`
}

===== FILE: ./config/logging.go =====
package config

type Logging struct {
	Level string `env:"LOG_LEVEL,default=info"`
}

===== FILE: ./config/http.go =====
package config

type HTTP struct {
	Addr string `env:"HTTP_ADDR,default=:8080"`
}

===== FILE: ./auth/provider.go =====
package auth

===== FILE: ./auth/service.go =====
package auth

===== FILE: ./auth/context.go =====
package auth

===== FILE: ./auth/password.go =====
package auth

===== FILE: ./auth/errors.go =====
package auth

===== FILE: ./http/server.go =====
package http

import (
	"context"
	"net/http"
	"time"

	"github.com/alexlup06/authgate/internal/auth"
	"github.com/alexlup06/authgate/internal/logging"
	"github.com/alexlup06/authgate/internal/session"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
)

type Server struct {
	httpServer *http.Server
}

type Config struct {
	Addr    string
	Auth    *auth.Service
	Session *session.Service
	Logger  *logging.Logger
}

func NewServer(cfg Config) *Server {
	r := chi.NewRouter()

	// ------------------------------------------------------------------
	// Global middleware (order matters)
	// ------------------------------------------------------------------
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Timeout(30 * time.Second))

	// Logging middleware (yours)
	r.Use(requestLogger(cfg.Logger))

	// ------------------------------------------------------------------
	// Routes
	// ------------------------------------------------------------------
	registerRoutes(r, cfg)

	srv := &http.Server{
		Addr:         cfg.Addr,
		Handler:      r,
		ReadTimeout:  15 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  60 * time.Second,
	}

	return &Server{httpServer: srv}
}

func (s *Server) Start() error {
	return s.httpServer.ListenAndServe()
}

func (s *Server) Shutdown(ctx context.Context) error {
	return s.httpServer.Shutdown(ctx)
}

===== FILE: ./http/context/user.go =====
package context

===== FILE: ./http/context/request.go =====
package context

===== FILE: ./http/routes.go =====
package http

import (
	"net/http"

	"github.com/go-chi/chi/v5"
)

func registerRoutes(r chi.Router, cfg Config) {
	// Health
	r.Get("/health", func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// Auth UI + API
	r.Route("/auth", func(r chi.Router) {
		h := newAuthHandler(cfg.Auth, cfg.Session)

		r.Get("/login", h.loginPage)
		r.Post("/login", h.login)
		r.Post("/logout", h.logout)

		r.Get("/signup", h.signupPage)
		r.Post("/signup", h.signup)
	})

	// Session validation (for SDK / backends)
	r.Get("/sessions/validate", func(w http.ResponseWriter, r *http.Request) {
		user, err := cfg.Session.ValidateRequest(r)
		if err != nil {
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		writeJSON(w, user)
	})
}

===== FILE: ./http/errors.go =====
package http

===== FILE: ./domain/auth_provider.go =====

===== FILE: ./domain/user.go =====

===== FILE: ./domain/session.go =====

===== FILE: ./logging/logging.go =====
package logging

import (
	"fmt"
	"os"
	"strings"

	"log/slog"
)

func New(level string) (*slog.Logger, error) {
	lvl, err := parseLevel(level)
	if err != nil {
		return nil, err
	}

	handler := slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
		Level: lvl,
	})

	return slog.New(handler), nil
}

func parseLevel(level string) (slog.Level, error) {
	switch strings.ToLower(level) {
	case "debug":
		return slog.LevelDebug, nil
	case "info":
		return slog.LevelInfo, nil
	case "warn", "warning":
		return slog.LevelWarn, nil
	case "error":
		return slog.LevelError, nil
	default:
		return slog.LevelInfo, fmt.Errorf("invalid log level: %s", level)
	}
}

===== FILE: ./logging/context.go =====
package logging

===== FILE: ./store/users.go =====
package store

===== FILE: ./store/sessions.go =====
package store

===== FILE: ./store/store.go =====
package store

import (
	"fmt"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
)

// Config is the configuration for the database.
type Config struct {
	Host     string `env:"POSTGRESQL_HOST, required"`
	Port     int    `env:"POSTGRESQL_PORT, required"`
	Username string `env:"POSTGRESQL_USERNAME, required"`
	Password string `env:"POSTGRESQL_PASSWORD, required"`
	Database string `env:"POSTGRESQL_DATABASE, required"`
	Timezone string `env:"POSTGRESQL_TIMEZONE, required"`
	Schema   string `env:"POSTGRESQL_SCHEMA, required"`
	LogSql   bool   `env:"POSTGRESQL_LOG_SQL, required"`
}

type Store struct {
	db *gorm.DB
}

func NewClient(cfg Config) (*Store, error) {
	dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s TimeZone=%s search_path=%s",
		cfg.Host, cfg.Port, cfg.Username, cfg.Password, cfg.Database, cfg.Timezone, cfg.Schema)

	var lg gormlogger.Interface
	if cfg.LogSql {
		lg = gormlogger.Default.LogMode(gormlogger.Info)
	}

	location, err := time.LoadLocation(cfg.Timezone)
	if err != nil {
		return nil, fmt.Errorf("can't load location %s: %w", cfg.Timezone, err)
	}

	gormConfig := gorm.Config{
		NowFunc: func() time.Time {
			return time.Now().In(location)
		},
		Logger:                 lg,
		SkipDefaultTransaction: true,
		PrepareStmt:            true,
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   cfg.Schema + ".",
			SingularTable: false,
		},
	}

	gormDB, err := gorm.Open(postgres.Open(dsn), &gormConfig)
	if err != nil {
		return nil, fmt.Errorf("error connecting to database: %w", err)
	}

	c := Store{db: gormDB}

	return &c, nil
}

===== FILE: ./store/auth_providers.go =====
package store

===== FILE: ./store/tx/manager.go =====
package tx

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"gorm.io/gorm"
)

type Manager struct {
	db *gorm.DB
}

func New(db *gorm.DB) *Manager {
	return &Manager{db: db}
}

type contextKey string

const (
	dbKey contextKey = "store.tx.db"
	txKey contextKey = "store.tx.state"
)

type transactionState struct {
	committed  bool
	rolledBack bool
}

// ---------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------

func (m *Manager) WithTransaction(
	ctx context.Context,
	fn func(context.Context) error,
) error {
	txCtx, cancel, err := m.withCancel(ctx)
	if err != nil {
		return err
	}
	defer cancel()

	if err := fn(txCtx); err != nil {
		if !isFinished(txCtx) {
			_ = m.Rollback(txCtx)
		}
		return err
	}

	if !isFinished(txCtx) {
		return m.Commit(txCtx)
	}

	return nil
}

func (m *Manager) Commit(ctx context.Context) error {
	db, err := getDB(ctx)
	if err != nil {
		return err
	}

	if err := db.Commit().Error; err != nil {
		return err
	}

	setCommitted(ctx)
	return nil
}

func (m *Manager) Rollback(ctx context.Context) error {
	if isCommitted(ctx) {
		return errors.New("transaction already committed")
	}

	db, err := getDB(ctx)
	if err != nil {
		return err
	}

	if err := db.Rollback().Error; err != nil {
		return err
	}

	setRolledBack(ctx)
	return nil
}

// ---------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------

func (m *Manager) withCancel(
	parent context.Context,
) (context.Context, context.CancelFunc, error) {
	ctx, cancel := context.WithCancel(parent)
	txCtx, err := m.withContext(ctx)
	return txCtx, cancel, err
}

func (m *Manager) withContext(
	parent context.Context,
) (context.Context, error) {
	session := m.db.
		WithContext(parent).
		Begin(&sql.TxOptions{
			Isolation: sql.LevelReadCommitted,
		})

	if session.Error != nil {
		return nil, session.Error
	}

	ctx := context.WithValue(parent, dbKey, session)
	ctx = context.WithValue(ctx, txKey, &transactionState{})

	go m.cleanup(ctx)

	return ctx, nil
}

func (m *Manager) cleanup(ctx context.Context) {
	<-ctx.Done()
	if !isFinished(ctx) {
		_ = m.Rollback(ctx)
	}
}

// ---------------------------------------------------------------------
// Context utilities (store-internal only)
// ---------------------------------------------------------------------

func getDB(ctx context.Context) (*gorm.DB, error) {
	db, ok := ctx.Value(dbKey).(*gorm.DB)
	if !ok {
		return nil, fmt.Errorf("no transaction in context")
	}
	return db, nil
}

func isCommitted(ctx context.Context) bool {
	state, ok := ctx.Value(txKey).(*transactionState)
	return ok && state.committed
}

func isFinished(ctx context.Context) bool {
	state, ok := ctx.Value(txKey).(*transactionState)
	return ok && (state.committed || state.rolledBack)
}

func setCommitted(ctx context.Context) {
	if state, ok := ctx.Value(txKey).(*transactionState); ok {
		state.committed = true
	}
}

func setRolledBack(ctx context.Context) {
	if state, ok := ctx.Value(txKey).(*transactionState); ok {
		state.rolledBack = true
	}
}

===== FILE: ./store/context.go =====
package store

import (
	"context"

	"gorm.io/gorm"
)

type contextKey string

const dbKey contextKey = "store.tx.db"

// dbFromContext returns a transactional DB if present, otherwise base DB.
func (s *Store) dbFromContext(ctx context.Context) *gorm.DB {
	if txDB, ok := ctx.Value(dbKey).(*gorm.DB); ok {
		return txDB
	}
	return s.db
}

===== FILE: ./store/model/auth_provider.go =====
package model

===== FILE: ./store/model/user.go =====
package model

===== FILE: ./store/model/session.go =====
package model

===== FILE: ./store/errors.go =====
package store

===== FILE: ./session/context.go =====
package session

===== FILE: ./session/cookie.go =====
package session

===== FILE: ./session/manager.go =====
package session

===== FILE: ./session/errors.go =====
package session

